package main

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
)

/*
=== Задача на распаковку ===

Создать Go функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы / руны, например:
	- "a4bc2d5e" => "aaaabccddddde"
	- "abcd" => "abcd"
	- "45" => "" (некорректная строка)
	- "" => ""
Дополнительное задание: поддержка escape - последовательностей
	- qwe\4\5 => qwe45 (*)
	- qwe\45 => qwe44444 (*)
	- qwe\\5 => qwe\\\\\ (*)

В случае если была передана некорректная строка функция должна возвращать ошибку. Написать unit-тесты.

Функция должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

// Unpack осуществляет примитивную распаковку строки
func Unpack(str string) (string, error) {
	// создаем словарь
	const (
		numbers = "0123456789"
		esc     = '\\'
	)

	var curr rune
	var r, nums []rune
	var escFlag bool

	// обходим все символы строки
	for i, c := range str {
		// проверяем отсутствие активированного флага escape-последовательности
		if !escFlag {
			// если текущий символ - /, то активируем флаг escape-последовательности
			// и переходим к следующему символу
			if c == esc {
				escFlag = true
				continue
			}
			// если текущий символ числовой, то добавляем его в срез числовых символов
			// и переходим к следующему символу,
			if strings.ContainsRune(numbers, c) {
				nums = append(nums, c)

				// если конец строки
				if i == len(str)-1 {
					if curr != 0 {
						// считываем из среза число
						num, _ := strconv.Atoi(string(nums))
						// добавляем в результирующий срез num-1 копий последнего добавленного символа
						for i := 0; i < num-1; i++ {
							r = append(r, curr)
						}
					}
					// обнуляем срез
					nums = []rune{}
				}
				continue
			}
		}

		// если срез числовых символов ненулевой
		if len(nums) > 0 {
			if curr != 0 {
				// считываем из среза число
				num, _ := strconv.Atoi(string(nums))
				// добавляем в результирующий срез num-1 копий последнего добавленного символа
				for i := 0; i < num-1; i++ {
					r = append(r, curr)
				}
			}
			// обнуляем срез
			nums = []rune{}
		}

		// деактивируем флаг escape-последовательности
		escFlag = false
		// добавляем символ в результирующий срез
		r = append(r, c)
		// сохраняем последнее добавленное значение
		curr = c
		continue
	}

	result := string(r)

	fmt.Println(len(result))
	// если результат пуст, а входная строка не пустая,
	// то выдаем ошибку
	if str != "" && result == "" {
		err := errors.New("некорректная строка")
		return "", err
	}

	return result, nil
}

func main() {

}
